from odoo import api, fields, models
from odoo.exceptions import UserError
from odoo.tools.translate import _


class AccountInvoice(models.Model):
    _inherit = 'account.invoice'

    contract_id = fields.Many2one(
        comodel_name='service.contract',
        string='Contract',
        ondelete='restrict',
        index=True)

    @api.multi
    def action_cancel(self):
        """Chama a função de cancelar do core para poder
        modificar a tela de fatura
        """
        super(AccountInvoice, self).action_cancel()

        if self.contract_id and self.state == 'cancel':
            # impede que uma fatura cancelada com contrato retorne para provisório
            self.block_draft_invoice = True

            # percorre as linhas da fatura e muda o status para 'approve'
            # para poder faturar novamente
            for rec in self.invoice_line_ids:
                if rec.contract_event_id:
                    rec.contract_event_id.state = 'approve'


    @api.multi
    def redirect_contract(self):
        self.ensure_one()

        action = self.env['ir.actions.act_window'].for_xml_id(
            'service_contract_management', 'service_contract_action')

        action['domain'] = [('id', '=', self.contract_id.id)]
        action['context'] = {}

        return action

    @api.multi
    def _hook_validation(self):
        """Valida dados da fatura, retornando uma lista
        com as mensagens de erro.

        Returns:
            list: Lista contendo as mensagens de erro
        """
        res = super(AccountInvoice, self)._hook_validation()

        if self.contract_id and any(line.contract_event_id.state != 'to_invoice' for line in self.invoice_line_ids):  # noqa
            raise UserError(_('This invoice cannot be validated because has at least one invoiced event!'))  # noqa

        return res

    @api.multi
    def action_br_account_invoice_open(self):

        res = super(AccountInvoice, self).action_br_account_invoice_open()

        if not (self.fiscal_document_id and self.contract_id and self.fiscal_document_id.electronic):  # noqa

            for line in self.invoice_line_ids.filtered(lambda r: r.contract_event_id):
                line.contract_event_id.state = 'invoice'

        return res

    @api.multi
    def action_invoice_cancel_paid(self):
        if self.contract_id and not (self.fiscal_document_id and self.fiscal_document_id.electronic):  # noqa

            for line in self.invoice_line_ids.filtered(lambda r: r.contract_event_id):
                line.contract_event_id.state = 'approve'

        return super(AccountInvoice, self).action_invoice_cancel_paid()

    @api.multi
    def unlink(self):
        for invoice in self:

            for line in invoice.invoice_line_ids.filtered(lambda r: r.contract_event_id):
                line.contract_event_id.state = 'approve'

        return super(AccountInvoice, self).unlink()

    # @api.multi
    # def copy(self):
    #     for invoice in self:
    #         if invoice.contract_id:
    #             raise UserError(
    #                 _("Cannot duplicate an invoice generated by contract, if "
    #                   "you need a copy of the current invoice, you can "
    #                   "generate another service from current contract, then "
    #                   "generate other events and invoice them"))
    #     return super(AccountInvoice, self).copy()
